// Copyright 2018 gopcua authors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

package uacp

import (
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestDecodeReverseHello(t *testing.T) {
	cases := []struct {
		input []byte
		want  *ReverseHello
	}{
		{ // Normal ReverseHello
			[]byte{
				// MessageType: RHE
				0x52, 0x48, 0x45,
				// Chunk Type: F
				0x46,
				// MessageSize: 12
				0x5c, 0x00, 0x00, 0x00,
				// ServerURI
				0x26, 0x00, 0x00, 0x00, 0x6f, 0x70, 0x63, 0x2e,
				0x74, 0x63, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x6f,
				0x77, 0x2e, 0x69, 0x74, 0x73, 0x2e, 0x65, 0x61,
				0x73, 0x79, 0x3a, 0x31, 0x31, 0x31, 0x31, 0x31,
				0x2f, 0x55, 0x41, 0x2f, 0x53, 0x65, 0x72, 0x76,
				0x65, 0x72,
				// EndPointURL
				0x26, 0x00, 0x00, 0x00, 0x6f, 0x70, 0x63, 0x2e,
				0x74, 0x63, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x6f,
				0x77, 0x2e, 0x69, 0x74, 0x73, 0x2e, 0x65, 0x61,
				0x73, 0x79, 0x3a, 0x31, 0x31, 0x31, 0x31, 0x31,
				0x2f, 0x55, 0x41, 0x2f, 0x53, 0x65, 0x72, 0x76,
				0x65, 0x72,
			},
			NewReverseHello(
				"opc.tcp://wow.its.easy:11111/UA/Server", // ServerURI
				"opc.tcp://wow.its.easy:11111/UA/Server", // EndPointURL
			),
		},
	}

	for i, c := range cases {
		got, err := DecodeReverseHello(c.input)
		if err != nil {
			t.Fatal(err)
		}

		got.Payload = nil
		if diff := cmp.Diff(got, c.want); diff != "" {
			t.Errorf("case #%d failed\n%s", i, diff)
		}
	}
}

func TestSerializeReverseHello(t *testing.T) {
	cases := []struct {
		input *ReverseHello
		want  []byte
	}{
		{ // Normal ReverseHello
			NewReverseHello(
				"opc.tcp://wow.its.easy:11111/UA/Server", // ServerURI
				"opc.tcp://wow.its.easy:11111/UA/Server", // EndPointURL
			),
			[]byte{
				// MessageType: RHE
				0x52, 0x48, 0x45,
				// Chunk Type: F
				0x46,
				// MessageSize: 12
				0x5c, 0x00, 0x00, 0x00,
				// ServerURI
				0x26, 0x00, 0x00, 0x00, 0x6f, 0x70, 0x63, 0x2e,
				0x74, 0x63, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x6f,
				0x77, 0x2e, 0x69, 0x74, 0x73, 0x2e, 0x65, 0x61,
				0x73, 0x79, 0x3a, 0x31, 0x31, 0x31, 0x31, 0x31,
				0x2f, 0x55, 0x41, 0x2f, 0x53, 0x65, 0x72, 0x76,
				0x65, 0x72,
				// EndPointURL
				0x26, 0x00, 0x00, 0x00, 0x6f, 0x70, 0x63, 0x2e,
				0x74, 0x63, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x6f,
				0x77, 0x2e, 0x69, 0x74, 0x73, 0x2e, 0x65, 0x61,
				0x73, 0x79, 0x3a, 0x31, 0x31, 0x31, 0x31, 0x31,
				0x2f, 0x55, 0x41, 0x2f, 0x53, 0x65, 0x72, 0x76,
				0x65, 0x72,
			},
		},
	}

	for i, c := range cases {
		got, err := c.input.Serialize()
		if err != nil {
			t.Fatal(err)
		}

		if diff := cmp.Diff(got, c.want); diff != "" {
			t.Errorf("case #%d failed\n%s", i, diff)
		}
	}
}
func TestReverseHelloLen(t *testing.T) {
	cases := []struct {
		input *ReverseHello
		want  int
	}{
		{ // Normal ReverseHello
			NewReverseHello(
				"opc.tcp://wow.its.easy:11111/UA/Server", // ServerURI
				"opc.tcp://wow.its.easy:11111/UA/Server", // EndPointURL
			),
			92,
		},
	}

	for i, c := range cases {
		got := c.input.Len()
		if diff := cmp.Diff(got, c.want); diff != "" {
			t.Errorf("case #%d failed\n%s", i, diff)
		}
	}
}
